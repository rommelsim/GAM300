#version 330 core
//out vec4 FragColor;
layout (location = 0) out vec4 color1;
layout (location = 1) out int  color2;
struct Material
{
    float shininess;
    sampler2D diffuseTexID;
    sampler2D specularTexID;
};

struct Light 
{
	vec3 position;		
    vec3 direction;

    float cutOff;
    float outerCutOff;

    vec3 color;
	vec3 ambient;			// universal light generated by engine

    float constant;
    float linear;
    float quadratic;

};

struct Spotlight
{
    vec3 position;
    float padding_0;

    vec3 direction;
    float padding_1;

    vec3 color;
    float padding_2;
    
    float cutOff;
    float outerCutOff;
    float constant;
    float linear;

    float quadratic;
    float intensity;
    float padding_3;
    float padding_4;
};

struct PointLight
{
    vec3 position;
    vec3 color;
};

in vec2 TexCoords;
in vec3 Normal;
in vec3 FragPos;
flat in int EntityID;

//uniform vec3 viewPos;

#define MAX_LIGHTS 20
uniform Material material;                  // Material
layout (std140) uniform Lighting
{
    Spotlight spotlights[MAX_LIGHTS];
    vec3 ambience;
    int counter;
    vec3 viewPos;
}block_lights;


// Function prototype
vec3 ComputePointlight(PointLight _pointlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir);
vec3 ComputeSpotlight(Spotlight _spotlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir);

void main()
{   
    // Properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(block_lights.viewPos - FragPos);

    vec3 result = vec3(block_lights.ambience) * texture(material.diffuseTexID, TexCoords).rgb;
    
    for(int i = 0; i < block_lights.counter; ++i)
    {
        result += ComputeSpotlight(block_lights.spotlights[i], norm, FragPos, viewDir);
    }
        
    color1 = vec4(result, 1.0);
    color2 = EntityID;
}

vec3 ComputeSpotlight(Spotlight _spotlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir)
{
    vec3 diffuse;

    vec3 lightDir = normalize(_spotlight.position - _fragPos);

    // Diffuse shading 
    float diff = max(dot(_normal, lightDir), 0.0);

    // TODO: Specular shading 

    // Attentuation 
    float distance = length(_spotlight.position - _fragPos);
    float attenuation = 1.0 / (_spotlight.constant + _spotlight.linear * distance + _spotlight.quadratic * (distance * distance));

    // Spotlight Intensity 
    float theta = dot(lightDir, normalize(-_spotlight.direction));
    float epsilon = _spotlight.cutOff - _spotlight.outerCutOff;
    float intensity = clamp((theta - _spotlight.outerCutOff) / epsilon, 0.0, 1.0);

    // Combine result
    diffuse = diff * vec3(texture(material.diffuseTexID, TexCoords)) * _spotlight.color;

    diffuse *= attenuation * intensity * _spotlight.intensity;

    return diffuse;
}


// Archive
  
 // ambient (from environment)
 // vec3 ambient = ambience * texture(material.diffuseTexID, TexCoords).rgb;
 // 
 // // diffuse (from light source)
 // float diff = max(dot(norm, lightDir), 0.0);
 // vec3 diffuse = diff * texture(material.diffuseTexID, TexCoords).rgb * spotlight.color;  
 // 
 // // // specular (from light source and perspective of the camera)
 // // vec3 reflectDir = reflect(-lightDir, norm);  
 // // float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
 // // vec3 specular = spec * texture(material.specularTexID, TexCoords).rgb;  
 // 
 // // attentuation
 // float distance = length(spotlight.position - FragPos);
 // float attenuation = 1.0 / (spotlight.constant + spotlight.linear * distance + 
 //         spotlight.quadratic * (distance * distance));
 // 
 // diffuse *= attenuation;
 // 
 // vec3 result = (ambient + diffuse + specular) * light.color;


// Improvement 
 
// forward rendering VS forward plus
// deferred rendering VS deffered plus
// tile rendering
// 
// forward plus: