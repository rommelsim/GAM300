#version 400 core
//#extension GL_EXT_gpu_shader4 : enable
//#extension GL_EXT_nonuniform_qualifier : require

layout (location = 0) out vec4 color1;
layout (location = 1) out int  color2;
layout (location = 2) out int  brightColor;

struct Material
{
    float shininess;
    sampler2D diffuseTexID;
    sampler2D specularTexID;
};

struct Light 
{
	vec3 position;		
    vec3 direction;

    float cutOff;
    float outerCutOff;

    vec3 color;
	vec3 ambient;			// universal light generated by engine

    float constant;
    float linear;
    float quadratic;

};

struct Spotlight
{
    vec3 position;
    float padding_0;

    vec3 direction;
    float padding_1;

    vec3 color;
    float padding_2;
    
    float cutOff;
    float outerCutOff;
    float constant;
    float linear;

    float quadratic;
    float intensity;
    float padding_3;
    float padding_4;

    mat4 lightMatrix;

    float PADDING_5;			// 4b
	float PADDING_6;			// 4b
	float PADDING_7;			// 4b
	int index;                // if -1 is does not have a shadow map, else have
};

struct PointLight
{
    vec3 position;
    float padding_0;
    
    float constant;
    float linear;
    float quadratic;  
    float padding_1;

    vec3 color;
    float padding_2;

    mat4 lightMatrix[6];    // 64*6 

    float padding_3;
    float padding_4;
    float intensity;
    int index;
};

struct DirectionalLight
{
    vec3 direction;
    float padding_0;

    vec3 color;
    float padding_1;

    mat4 lightMatrix;

    float padding_2;
    float padding_3;
    float intensity;
    int index;
};

in vec2 TexCoords;
in vec3 Normal;
in vec3 FragPos;
//in vec4 FragPosLightSpace;
flat in int EntityID;

//uniform vec3 viewPos;

#define MAX_LIGHTS 5
uniform Material material;                  // Material
layout (std140) uniform Lighting
{
    Spotlight spotlights[MAX_LIGHTS];
    PointLight pointlights[MAX_LIGHTS];
    DirectionalLight directionallights[MAX_LIGHTS];
    vec3 ambience;
    
    int size_spotLight;
    int size_pointLight;
    int size_directionalLight;

    vec3 viewPos;
}block_lights;


// Function prototype
vec3 ComputePointlight(PointLight _pointlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir);
vec3 ComputeSpotlight(Spotlight _spotlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir);
vec3 ComputeDirectionallight(DirectionalLight _directionallight, vec3 _normal, vec3 _fragPos, vec3 _viewDir);

vec3 sampleOffsetDirections[20] = vec3[]
(
   vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1), 
   vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),
   vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),
   vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),
   vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)
); 

// Shadow Calculation
//uniform sampler2D shadowMap;
uniform sampler2D shadowMap_Spotlights[MAX_LIGHTS];
uniform sampler2D shadowMap_Directionallights[MAX_LIGHTS];
uniform samplerCube shadowMap_Pointlights[MAX_LIGHTS];
uniform float far_plane;

// Gamma
uniform float gamma;
uniform bool hdr;

const float bias = 1.0f;

float ShadowCalculation(vec3 fragPos, PointLight light)
{
    // get vector between fragment position and light position
    vec3 fragToLight = fragPos - light.position;

    // use the fragment to light vector to sample from the depth map    
    float closestDepth = texture(shadowMap_Pointlights[light.index], fragToLight).r;

    // it is currently in linear range between [0,1], let's re-transform it back to original depth value
    closestDepth *= far_plane;

    // now get current linear depth as the length between the fragment and light position
    float currentDepth = length(fragToLight);
    
    float shadow = currentDepth - bias > closestDepth ? 1.0 : 0.0;      
    
    return shadow;
}

float ShadowCalculation(vec4 fragPosLightSpace, DirectionalLight light)
{
    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;

    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;

    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap_Directionallights[light.index], projCoords.xy).r; 

    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // check whether current frag pos is in shadow
    // float bias = 0.005;
    float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;  

    return shadow;
}  

float ShadowCalculation(vec4 fragPosLightSpace, Spotlight light)
{
    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;

    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;

    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap_Spotlights[light.index], projCoords.xy).r; 

    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;

    // check whether current frag pos is in shadow
    // float bias = 0.005;
    float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;  

    return shadow;
}  

// Tone mapping function
vec3 ToneMapReinhard(vec3 color) {
    return color / (color + vec3(1.0));
}
void main()
{   
    // Properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(block_lights.viewPos - FragPos);

    vec3 result = vec3(block_lights.ambience);
    
    // Spotlight
    for(int i = 0; i < block_lights.size_spotLight; ++i)
        result += ComputeSpotlight(block_lights.spotlights[i], norm, FragPos, viewDir);

    // Point light
     for(int j = 0; j < block_lights.size_pointLight; ++j)
        result += ComputePointlight(block_lights.pointlights[j], norm, FragPos, viewDir);
    
    // direciotnal light
    for(int k = 0; k < block_lights.size_directionalLight; ++k)
       result += ComputeDirectionallight(block_lights.directionallights[k], norm, FragPos, viewDir);

    result *= texture(material.diffuseTexID, TexCoords).rgb;

    vec3 hdrColor = result;
    vec3 toneMappedColor = ToneMapReinhard(hdrColor);


      // Apply gamma correction (assuming gamma = 2.2)
      vec3 gammaCorrectedColor = vec3(1.0f);

      if(hdr)
        gammaCorrectedColor = pow(toneMappedColor, vec3(1.0 / gamma));
      else
        gammaCorrectedColor = pow(result, vec3(1.0 / gamma));

    color1 = vec4(gammaCorrectedColor, 1.0);
    color2 = EntityID;
    
}

vec3 ComputeDirectionallight(DirectionalLight _directionallight, vec3 _normal, vec3 _fragPos, vec3 _viewDir)
{

    float shadow;
    vec3 diffuse;
    vec3 lightDir = normalize(-_directionallight.direction);

    // diffuse shading
    float diff = max(dot(_normal, lightDir), 0.0);

    if(all(greaterThan(_directionallight.color, vec3(0.0))))
    {
        diffuse = diff * vec3(texture(material.diffuseTexID, TexCoords)) * _directionallight.color * _directionallight.intensity;
        shadow = ShadowCalculation(_directionallight.lightMatrix * vec4(FragPos, 1.0), _directionallight);
    }
    return (1.0 - shadow) * diffuse;

}

vec3 ComputePointlight(PointLight _pointlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir)
{

    float shadow;
    vec3 diffuse;
    vec3 lightDir = normalize(_pointlight.position - _fragPos);

    // diffuse shading
    float diff = max(dot(_normal, lightDir), 0.0);

     // attenuation
    float distance    = length(_pointlight.position - _fragPos);
    float attenuation = 1.0 / (_pointlight.constant + _pointlight.linear * distance + _pointlight.quadratic * (distance * distance));    

    if(all(greaterThan(_pointlight.color, vec3(0.0))))
    {
        diffuse = diff * vec3(texture(material.diffuseTexID, TexCoords)) * _pointlight.color * _pointlight.intensity;
        diffuse *= attenuation;

        // Compute shadows for pointlight!
        shadow = ShadowCalculation(_fragPos, _pointlight);
    }
     return (1.0 - shadow) * diffuse;

}

vec3 ComputeSpotlight(Spotlight _spotlight, vec3 _normal, vec3 _fragPos, vec3 _viewDir)
{
    float shadow;
    vec3 diffuse;
    vec3 specular;

    vec3 lightDir = normalize(_spotlight.position - _fragPos);

    // Diffuse shading 
    float diff = max(dot(_normal, lightDir), 0.0);

    // specular shading
    vec3 reflectDir = reflect(-lightDir, _normal);
    float spec = pow(max(dot(_viewDir, reflectDir), 0.0), material.shininess);

    // Attentuation 
    float distance = length(_spotlight.position - _fragPos);
    float attenuation = 1.0 / (_spotlight.constant + _spotlight.linear * distance + _spotlight.quadratic * (distance * distance));

    // Spotlight Intensity 
    float theta = dot(lightDir, normalize(-_spotlight.direction));
    float epsilon = _spotlight.cutOff - _spotlight.outerCutOff;
    float intensity = clamp((theta - _spotlight.outerCutOff) / epsilon, 0.0, 1.0);

    // Combine result
    if(all(greaterThan(_spotlight.color, vec3(0.0))))
    {
        diffuse = diff * vec3(texture(material.diffuseTexID, TexCoords)) * _spotlight.color;
        diffuse *= attenuation * intensity * _spotlight.intensity;
        
        specular = spec * vec3(texture(material.specularTexID, TexCoords));

       shadow = ShadowCalculation(_spotlight.lightMatrix * vec4(FragPos, 1.0), _spotlight);

    }
	return (1.0 - shadow) * diffuse;
    //return diffuse + specular;
}
